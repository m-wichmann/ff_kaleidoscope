#!/usr/bin/env python3

import argparse
import subprocess
import codecs
import tempfile
import os
import json
import math
from PIL import Image, ImageDraw
from dataclasses import dataclass


@dataclass 
class Resolution:
    w: float
    h: float


@dataclass
class Tile:
    x: float
    y: float
    rot: float
    mirror: bool
    level: int
    alpha_color: int


class Tiling(object):
    def __init__(self, resolution, n, r):
        if (n != 3) and (n != 4) and (n != 6):
            print('n invalid! Nonregular tilings currently not supported')

        if (n != 3):
            print('n invalid! Currently only 3 is supported (rest is buggy)')

        self.tiling = None
        self.resolution = resolution
        self.n = n
        self.r = r
        self.poly_angle = 180 / self.n

    def get_tiling(self):
        # TODO: Refactor as Generator or something
        return self.tiling

    @staticmethod
    def circle_intersects_rectangle(circle_center_x, circle_center_y, circle_radius, rect_x, rect_y, rect_width, rect_height):
        """Code generated by ChatGPT"""
        # Calculate closest point on the rectangle to the circle
        closest_x = max(rect_x, min(circle_center_x, rect_x + rect_width))
        closest_y = max(rect_y, min(circle_center_y, rect_y + rect_height))

        # Calculate distance between the closest point and circle center
        distance = math.sqrt((closest_x - circle_center_x) ** 2 + (closest_y - circle_center_y) ** 2)

        # If distance is less than or equal to circle radius, they intersect
        return distance <= circle_radius

    def gen_tiling(self):
        a = self.r * math.cos(math.pi / self.n)       # Apothem; Source: https://en.wikipedia.org/wiki/Apothem

        tiling = [Tile(self.resolution.w/2, self.resolution.h/2, 0, False, 0, 0)]
        while True:
            new_tiling_appended = False
            new_tiling = tiling.copy()
            for tile in tiling:
                pnts = ImageDraw._compute_regular_polygon_vertices((tile.x, tile.y, self.r), self.n, rotation=tile.rot)
                apos = [(((pnt[0][0]+pnt[1][0])/2), ((pnt[0][1]+pnt[1][1])/2)) for pnt in zip(pnts, pnts[1:] + [pnts[0]])]
                for apo in apos:
                    _x, _y = (tile.x - self.r * math.sin(math.radians(tile.rot)), tile.y - self.r * math.cos(math.radians(tile.rot)))
                    angle = math.atan2(apo[1] - tile.y, apo[0] - tile.x) - math.atan2(_y - tile.y, _x - tile.x)
                    angle = (angle / (math.pi / 180)) % 360
                    angle = round(angle / self.poly_angle) * self.poly_angle

                    # TODO: Angle is wrong for n==4 and n==6
                    new_tile = Tile(tile.x+2*(apo[0]-tile.x), tile.y+2*(apo[1]-tile.y), (tile.rot+angle)%360, not tile.mirror, tile.level+1, 0)

                    is_new_tiling = True
                    for tiling_tmp in new_tiling:
                        # Check if Tile is already in list (merge radius a/2)
                        if (abs(tiling_tmp.x - new_tile.x) < (a / 2)) and (abs(tiling_tmp.y - new_tile.y) < (a / 2)):
                            is_new_tiling = False
                            break

                        # Check if Tile is visible
                        if not Tiling.circle_intersects_rectangle(new_tile.x, new_tile.y, self.r, 0, 0, self.resolution.w, self.resolution.h):
                            is_new_tiling = False
                            break

                    if is_new_tiling:
                        new_tiling.append(new_tile)
                        new_tiling_appended = True
            tiling = new_tiling
            if not new_tiling_appended:
                break
        self.tiling = tiling

    def draw_debug_image(self, filepath):
        with Image.new('RGB', (self.resolution.w, self.resolution.h)) as im:
            draw = ImageDraw.Draw(im)
            for tile in self.tiling:
                pnts = ImageDraw._compute_regular_polygon_vertices((tile.x, tile.y, self.r), self.n, rotation=tile.rot)
                apos = [(((e[0][0] + e[1][0]) / 2), ((e[0][1] + e[1][1]) / 2)) for e in zip(pnts, pnts[1:] + [pnts[0]])]

                draw.regular_polygon((tile.x, tile.y, self.r), self.n, rotation=tile.rot, fill=(50, 50, 50), outline=(0, 255, 0))
                draw.point((tile.x, tile.y), fill=(0,0,255))
                for e in apos:
                    draw.point(e, fill=(255,0,0))
                _x, _y = (tile.x - self.r * math.sin(math.radians(tile.rot))), (tile.y - self.r * math.cos(math.radians(tile.rot)))
                draw.line([(tile.x, tile.y), (_x, _y)], (255, 0, 0) if tile.mirror else (255, 255, 255))
                draw.text((tile.x, tile.y), f"{tile.rot:.2f}")
            draw.point((self.resolution.w / 2, self.resolution.h / 2), (255, 255, 255))
            im.save(filepath)

    def draw_alpha_images(self, outdir):
        for i, tile in enumerate(self.tiling):
            with Image.new('L', (self.resolution.w, self.resolution.h)) as im:
                draw = ImageDraw.Draw(im)
                draw.regular_polygon((tile.x, tile.y, self.r), self.n, rotation=tile.rot, fill=255, outline=255)
                im.save(os.path.join(outdir, f"img_{i:03}.png"))

    def draw_alpha_image_with_colors(self, filepath):
        min_color_distance = math.ceil(2**24 * Kaleidoscope.COLORKEY_SIMILARITY)

        if min_color_distance * len(self.tiling) >= 2**24:
            print('Too many tiles, color distance is not enough for colorkey filter!')

        with Image.new('RGB', (self.resolution.w, self.resolution.h)) as im:
            draw = ImageDraw.Draw(im)
            for i, tile in enumerate(self.tiling):
                tile.alpha_color = (i + 1) * min_color_distance
                color = f'#{tile.alpha_color:06x}'
                draw.regular_polygon((tile.x, tile.y, self.r), self.n, rotation=tile.rot, fill=color, outline=color)
            im.save(filepath)


class Ffmpeg(object):
    FFMPEG_BIN = 'ffmpeg'
    FFPROBE_BIN = 'ffprobe'

    @staticmethod
    def popen_wrapper(cmd, timeout=None):
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        retval = None
        stdout = ''
        stderr = ''

        try:
            stdout, stderr = proc.communicate(timeout=timeout)
        except (subprocess.TimeoutExpired, KeyboardInterrupt):
            proc.kill()
            stdout, stderr = proc.communicate()

        retval = proc.returncode

        stdout = codecs.decode(stdout, 'utf-8', 'replace')
        stderr = codecs.decode(stderr, 'utf-8', 'replace')

        return (retval, stdout, stderr)

    @staticmethod
    def get_stream_details(filepath):
        cmd  = [Ffmpeg.FFPROBE_BIN]
        cmd += ['-v', 'error']
        cmd += ['-select_streams', 'v:0']
        cmd += ['-show_entries', 'format=duration:stream=width,height', '-of', 'json']
        cmd += [filepath]
        retval, stdout, stderr = Ffmpeg.popen_wrapper(cmd)
        raw_data = json.loads(stdout)
        data = {}
        data['width'] = float(raw_data['streams'][0]['width'])
        data['height'] = float(raw_data['streams'][0]['height'])
        data['duration'] = float(raw_data['format']['duration'])
        return data

    @staticmethod
    def call_ffmpeg(input_video_path, input_alpha_img_path, output_path, filter, output_duration, overwrite=False):
        cmd  = [Ffmpeg.FFMPEG_BIN]

        # NOTE: If nullsink is used for video input, '-t' should be set, because '-to' is not respected!
        cmd += ['-t', str(output_duration)]
        cmd += ['-i', input_video_path]

        cmd += ['-loop', str(1)]
        cmd += ['-t', str(output_duration)]
        cmd += ['-i', input_alpha_img_path]

        cmd += ['-filter_complex', filter]
        cmd += ['-map', '[output]']

        cmd += ['-to', str(output_duration)]

        cmd += ['-c:v', 'libx264']

        # NOTE: Make cancelled encodings viewable (mostly for easier testing)
        cmd += ['-movflags', '+frag_keyframe+empty_moov+faststart']

        cmd += ['-c:a', 'copy']

        cmd += ['-nostdin']

        if overwrite:
            cmd += ['-y']

        cmd += [output_path]

        (retval, stdout, stderr) = Ffmpeg.popen_wrapper(cmd)
        if retval:
            print(stderr)


class Kaleidoscope(object):
    POLYGON_TRIANGLE = 3
    COLORKEY_SIMILARITY = 0.00001

    def __init__(self, poly_n, poly_r_factor, rotation_base=0, rotation_factor=0, brightness_factor=-0.05, verbose=False):
        self.poly_n = poly_n
        self.poly_r_factor = poly_r_factor
        self.rotation_base = rotation_base
        self.rotation_factor = rotation_factor
        self.brightness_factor = brightness_factor
        self.verbose = verbose

    def gen_kaleidoscope(self, input_file, output_file, output_res=(1920, 1080), output_duration=None, overwrite=False):
        input_stream_details = Ffmpeg.get_stream_details(input_file)

        poly_r = min(output_res.w, output_res.h) * self.poly_r_factor / 2

        scale_factor = min(input_stream_details['width'], input_stream_details['height']) / (2 * poly_r)
        scaled_res = Resolution(input_stream_details['width'] / scale_factor, input_stream_details['height'] / scale_factor)

        tmp_hypot = math.floor(math.sqrt(output_res.w**2 + output_res.h**2) / 2) * 2
        self.internal_res = Resolution(tmp_hypot, tmp_hypot)

        output_duration = output_duration if output_duration else input_stream_details['duration']

        alpha_file_path = tempfile.NamedTemporaryFile(suffix='.png')

        tiling = Tiling(self.internal_res, self.poly_n, poly_r)
        tiling.gen_tiling()
        tiling.draw_alpha_image_with_colors(alpha_file_path.name)

        filter  = f""

        # Prepare main inputs (background, video and alpha)
        filter += f"color=c=black : s={self.internal_res.w}x{self.internal_res.h} : d={output_duration} [bg];\n"
        filter += f"[0:v] scale=w={scaled_res.w} : h={scaled_res.h}, split=2 [video_main][video_main_tmp];\n"
        filter += f"[video_main_tmp] hflip [video_main_hflip];\n"
        filter += f"[1:v] format=rgba [alpha_main];\n"

        # Prepare all possible rotations/flips
        video_stream_idx = 0
        video_streams = {}
        for tile in tiling.get_tiling():
            if (tile.mirror, tile.rot) not in video_streams:
                video_stream_name = f'video_main_{video_stream_idx}'
                video_streams[(tile.mirror, tile.rot)] = video_stream_name
                video_stream_idx += 1
                if tile.mirror:
                    filter += f"[video_main_hflip] split=2 [video_main_hflip][{video_stream_name + '_tmp'}];\n"
                    filter += f"[{video_stream_name + '_tmp'}] rotate='(-{tile.rot}+({self.rotation_base}+t*{self.rotation_factor}))*{math.pi/180}:ow=hypot(iw,ih):oh=ow' [{video_stream_name}];\n"
                else:
                    filter += f"[video_main] split=2 [video_main][{video_stream_name + '_tmp'}];\n"
                    filter += f"[{video_stream_name + '_tmp'}] rotate='(-{tile.rot}-({self.rotation_base}+t*{self.rotation_factor}))*{math.pi/180}:ow=hypot(iw,ih):oh=ow' [{video_stream_name}];\n"

        for i, tile in enumerate(tiling.get_tiling()):
            # Copy all relevant streams
            filter += f"[{video_streams[(tile.mirror, tile.rot)]}] split=2 [{video_streams[(tile.mirror, tile.rot)]}][video_tmp{i}_video];\n"
            filter += f"[alpha_main] split=2 [alpha_main][video_tmp{i}_alpha];\n"
            filter += f"[bg] split=2 [bg][video_tmp{i}_bg];\n"

            # Overlay selected video on background, add brightness correction per mirror, extract alpha from image by color (invert because who knows), merge alpha into final image
            filter += f"[video_tmp{i}_bg][video_tmp{i}_video] overlay=x={tile.x}-overlay_w/2:y={tile.y}-overlay_h/2:eval=init, eq=brightness={tile.level*self.brightness_factor} [video_tmp{i}_ov];\n"
            filter += f"[video_tmp{i}_alpha] colorkey=color=0x{tile.alpha_color:06x}:similarity=0.00001, negate=a, alphaextract [video_tmp{i}_alpha_tmp];\n"
            filter += f"[video_tmp{i}_ov][video_tmp{i}_alpha_tmp] alphamerge [video_tmp{i}_out];\n"

        # Mix all output streams, rotate and crop
        filter += f"[bg] split=2 [bg][video_ov0];\n"
        for i, tile in enumerate(tiling.get_tiling()):
            filter += f"[video_ov{i}][video_tmp{i}_out] overlay=eval=init [video_ov{i+1}];\n"
        filter += f"[video_ov{len(tiling.get_tiling())}] rotate='({self.rotation_base}+t*{self.rotation_factor})*{math.pi/180}:ow={output_res.w}:oh={output_res.h}' [output];\n"

        # Clean up all remaining streams
        for video_stream in video_streams:
            filter += f"[{video_streams[video_stream]}] nullsink;\n"
        filter += f"[video_main] nullsink;\n"
        filter += f"[video_main_hflip] nullsink;\n"
        filter += f"[alpha_main] nullsink;\n"
        filter += f"[bg] nullsink;\n"

        if self.verbose:
            print(filter)

        Ffmpeg.call_ffmpeg(input_file, alpha_file_path.name, output_file, filter, output_duration, overwrite)

        del alpha_file_path


parser = argparse.ArgumentParser(prog='ff_kaleidoscope')
parser.add_argument('-y', '--overwrite', action='store_true', help='Overwrite output if file already exists')
parser.add_argument('-r', '--resolution', default='1280x720')
parser.add_argument('-d', '--duration')
parser.add_argument('-p', '--polygon-factor', default=1.3)
parser.add_argument('-b', '--rotation-base', default=0)
parser.add_argument('-f', '--rotation-factor', default=20)
parser.add_argument('-l', '--brightness', default=-0.05)
parser.add_argument('-v', '--verbose', action='store_true')
parser.add_argument('input')
parser.add_argument('output')
args = parser.parse_args()

_resolution = args.resolution.split('x')
_resolution = Resolution(int(_resolution[0]), int(_resolution[1]))

kaleidoscope = Kaleidoscope(Kaleidoscope.POLYGON_TRIANGLE, float(args.polygon_factor), rotation_base=args.rotation_base, rotation_factor=args.rotation_factor, brightness_factor=args.brightness, verbose=args.verbose)
kaleidoscope.gen_kaleidoscope(args.input, args.output, _resolution, args.duration, overwrite=args.overwrite)
